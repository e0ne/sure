{"tagline":"fluent testing for python","note":"Don't delete this file! It's used internally to help with page regeneration.","body":"## sure `1.0.4` - utility belt for automated testing in python (inspired by [should.js](https://github.com/visionmedia/should.js/) )\r\n[![Build Status](https://secure.travis-ci.org/gabrielfalcao/sure.png)](http://travis-ci.org/gabrielfalcao/sure)\r\n\r\n```python\r\nfrom sure import version\r\n\r\nversion.should.be.equal('1.0.4')\r\n```\r\n\r\n# Installing\r\n\r\n    user@machine:~$ [sudo] pip install sure\r\n\r\n# Fluent assertions\r\n\r\n> available only on cpython (no support for Jython, IronPython, PyPy, etc)\r\n\r\nMind-blowing easy and fluent assertions.\r\n\r\n\r\n#### `(number).should.equal(number)`\r\n\r\n```python\r\nimport sure\r\n\r\n(4).should.be.equal(2 + 2)\r\n(7.5).should.eql(3.5 + 4)\r\n(2).should.equal(8 / 4)\r\n\r\n(3).shouldnt.be.equal(5)\r\n```\r\n\r\n#### `{'a': 'collection'}.should.equal({'a': 'collection'})` does deep comparison\r\n\r\n```python\r\n{'foo': 'bar'}.should.equal({'foo': 'bar'})\r\n{'foo': 'bar'}.should.eql({'foo': 'bar'})\r\n{'foo': 'bar'}.must.be.equal({'foo': 'bar'})\r\n\r\n```\r\n\r\n#### `\"A string\".lower().should.equal(\"a string\")` also works\r\n\r\n```python\r\n\"Awesome ASSERTIONS\".lower().split().should.equal(['awesome', 'assertions'])\r\n```\r\n\r\n#### `{iterable}.should.be.empty` applies to any iterable of length 0\r\n\r\n```python\r\n\r\n[].should.be.empty;\r\n{}.should.be.empty;\r\nset().should.be.empty;\r\n\"\".should.be.empty;\r\n().should.be.empty\r\nrange(0).should.be.empty;\r\n\r\n# negate with:\r\n\r\n[1, 2, 3].shouldnt.be.empty;\r\n\"Lincoln de Sousa\".shouldnt.be.empty;\r\n\"Lincoln de Sousa\".should_not.be.empty;\r\n\r\n```\r\n\r\n\r\n#### `{number}.should.be.within(0, 10)` asserts inclusive numeric range:\r\n\r\n```python\r\n(1).should.be.within(0, 2)\r\n(5).should.be.within(10)\r\n\r\n# negate with:\r\n\r\n(1).shouldnt.be.within(5, 6)\r\n```\r\n\r\n#### `{member}.should.be.within({iterable})` asserts that a member is part of the iterable:\r\n\r\n```python\r\n\"g\".should.be.within(\"gabriel\")\r\n'name'.should.be.within({'name': 'Gabriel'})\r\n'Lincoln'.should.be.within(['Lincoln', 'Gabriel'])\r\n\r\n# negate with:\r\n\r\n'Bug'.shouldnt.be.within(['Sure 1.0'])\r\n'Bug'.should_not.be.within(['Sure 1.0'])\r\n\r\n```\r\n\r\n#### `should.be.ok` and `shouldnt.be.ok`\r\n\r\nAssert truthfulness:\r\n\r\n```python\r\nfrom sure import this\r\n\r\nTrue.should.be.ok\r\n'truthy tring'.should.be.ok\r\n{'truthy': 'dictionary'}.should.be.ok\r\n```\r\n\r\nAnd negate truthfulness:\r\n\r\n```python\r\n\r\nfrom sure import this\r\n\r\nFalse.shouldnt.be.ok\r\n''.should_not.be.ok\r\n{}.shouldnot.be.ok\r\n```\r\n\r\n#### Assert the length of objects with `{iterable}.should.have.length_of(N)`\r\n\r\n```python\r\n\r\n[3, 4].should.have.length_of(2)\r\n\r\n\"Python\".should.have.length_of(6)\r\n\r\n{'john': 'person'}.should_not.have.length_of(2)\r\n```\r\n\r\n#### `callable.when.called_with(arg1, kwarg1=2).should.throw(Exception)`\r\n\r\nYou can use this feature to assert that a callable raises an\r\nexception:\r\n\r\n```python\r\nimport sure\r\n\r\nrange.when.called_with(10, step=\"20\").should.throw(TypeError, \"range() takes no keyword arguments\")\r\nrange.when.called_with(\"chuck norris\").should.throw(\"range() integer end argument expected, got str.\")\r\nrange.when.called_with(\"chuck norris\").should.throw(TypeError)\r\nrange.when.called_with(10).should_not.throw(TypeError)\r\n```\r\n\r\n#### `function.when.called_with(arg1, kwarg1=2).should.return_value(value)`\r\n\r\nThis is a shorthand for testing that a callable returns the expected\r\nresult\r\n\r\n```python\r\nimport sure\r\n\r\nrange.when.called_with(2).should.return_value([0, 1])\r\n```\r\n\r\nthis is the same as\r\n\r\n```\r\nvalue = range(2)\r\nvalue.should.equal([0, 1])\r\n```\r\n\r\nthere are no differences between those 2 possibilities, use at will\r\n\r\n#### `instance.should.be.a('typename')` and `instance.should.be.an('typename')`\r\n\r\nthis takes a type name and checks if the class matches that name\r\n\r\n```python\r\nimport sure\r\n\r\n{}.should.be.a('dict')\r\n(5).should.be.an('int')\r\n\r\n# also works with paths\r\n\r\nrange(10).should.be.a('collections.Iterable')\r\n```\r\n\r\n#### `instance.should.be.a(type)` and `instance.should.be.an(type)`\r\n\r\nthis takes the class (type) itself and checks if the object is an instance of it\r\n\r\n```python\r\nimport sure\r\n\r\nu\"\".should.be.an(unicode)\r\n[].should.be.a(list)\r\n```\r\n\r\n#### `instance.should.be.above(num)` and `instance.should.be.below(num)`\r\n\r\nassert the instance value above and below `num`\r\n\r\n```python\r\nimport sure\r\n\r\n(10).should.be.below(11)\r\n(10).should.be.above(9)\r\n(10).should_not.be.above(11)\r\n(10).should_not.be.below(9)\r\n```\r\n\r\n\r\n# Static assertions with `it`, `this`, `those` and `these`\r\n\r\n#### `exists()` and `should.exist()` asserts that the given object is truthy\r\n\r\n```python\r\nfrom sure import it, this, these, those\r\n\r\nassert it.should.exist(True)\r\nassert it.exists(object())\r\n\r\nassert this.should.exist(True)\r\nassert this.exists(object())\r\n\r\nassert it.should.exist(True)\r\nassert it.exists(object())\r\n\r\nassert this.should.exists(True)\r\nassert this.should.exists(object())\r\n\r\nbugs = []\r\nassert those.shouldnt.exist(bugs)\r\n\r\nusers = []\r\nassert these.shouldnt.exist(users)\r\n\r\n```\r\n\r\n### A note about the `assert` keyword\r\n\r\n_you can use or not the_ `assert` _keyword, sure internally already\r\nraises an appropriate_ `AssertionError` _with an assertion message so\r\nthat you don't have to specify your own, but you can still use_\r\n`assert` _if you find it more semantic_\r\n\r\nExample:\r\n\r\n```python\r\nimport sure\r\n\r\n\"Name\".lower().should.equal('name')\r\n\r\n# or you can also use\r\n\r\nassert \"Name\".lower().should.equal('name')\r\n\r\n# or still\r\n\r\nfrom sure import this\r\n\r\nassert this(\"Name\".lower()).should.equal('name')\r\n\r\n# also without the `assert`\r\n\r\nthis(\"Name\".lower()).should.equal('name')\r\n\r\n```\r\n\r\nAny of the examples above will raise their own `AssertionError` with a\r\nmeaningful error message.\r\n\r\n\r\n#### `dont.exists()`, `doesnt.exists()` and `shouldnt.exist()` asserts that the given object is falsy\r\n\r\n```python\r\nfrom sure import it, this, these, those\r\n\r\nassert it.dont.exist({})\r\nassert it.dont.exist([])\r\nassert it.dont.exist('')\r\nassert it.dont.exist(False)\r\nassert it.dont.exist(None)\r\n\r\nassert these.dont.exist({})\r\nassert these.dont.exist([])\r\nassert these.dont.exist('')\r\nassert these.dont.exist(False)\r\nassert these.dont.exist(None)\r\n\r\nassert it.doesnt.exist({})\r\nassert it.doesnt.exist([])\r\nassert it.doesnt.exist('')\r\nassert it.doesnt.exist(False)\r\nassert it.doesnt.exist(None)\r\n\r\nassert those.doesnt.exist({})\r\nassert those.doesnt.exist([])\r\nassert those.doesnt.exist('')\r\nassert those.doesnt.exist(False)\r\nassert those.doesnt.exist(None)\r\n\r\nassert this.dont.exist({})\r\nassert this.dont.exist([])\r\nassert this.dont.exist('')\r\nassert this.dont.exist(False)\r\nassert this.dont.exist(None)\r\n\r\nassert this.doesnt.exist({})\r\nassert this.doesnt.exist([])\r\nassert this.doesnt.exist('')\r\nassert this.doesnt.exist(False)\r\nassert this.doesnt.exist(None)\r\n\r\nassert it.shouldnt.exist({})\r\nassert it.shouldnt.exist([])\r\nassert it.shouldnt.exist('')\r\nassert it.shouldnt.exist(False)\r\nassert it.shouldnt.exist(None)\r\n\r\nassert this.shouldnt.exist({})\r\nassert this.shouldnt.exist([])\r\nassert this.shouldnt.exist('')\r\nassert this.shouldnt.exist(False)\r\nassert this.shouldnt.exist(None)\r\n```\r\n\r\n# Synonyms\r\n\r\nSure provides you with a lot of synonyms so that you can pick the ones\r\nthat makes more sense for your tests.\r\n\r\nNote that the examples below are merely illustrative, they work not\r\nonly with numbers but with any of the assertions you read early in\r\nthis documentation.\r\n\r\n## Positive synonyms\r\n\r\n```python\r\n\r\n(2 + 2).should.be.equal(4)\r\n(2 + 2).must.be.equal(4)\r\n(2 + 2).does.equals(4)\r\n(2 + 2).do.equals(4)\r\n```\r\n\r\n## Negative synonyms\r\n\r\n```python\r\n\r\n(2).should_not.be.equal(3)\r\n(2).shouldnt.be.equal(3)\r\n(2).doesnt.equals(3)\r\n(2).does_not.equals(3)\r\n(2).doesnot.equals(3)\r\n(2).dont.equal(3)\r\n(2).do_not.equal(3)\r\n```\r\n\r\n## Equality synonyms\r\n\r\n```python\r\n\r\n(2).should.equal(2)\r\n(2).should.equals(2)\r\n(2).should.eql(2)\r\n```\r\n\r\n## Existence synonyms\r\n\r\n```python\r\n\r\nassert it.do.exists(1)\r\nassert it.should.exist(1)\r\n```\r\n\r\n## Positive boolean synonyms\r\n\r\n```python\r\n\r\n(not None).should.be.ok;\r\n(not None).should.be.truthy;\r\n(not None).should.be.true;\r\n```\r\n\r\n## Negative boolean synonyms\r\n\r\n```python\r\nFalse.should.be.falsy;\r\nFalse.should.be.false;\r\nNone.should.be.none;\r\nFalse.should_not.be.true;\r\nFalse.should_not.be.ok;\r\nNone.should_not.be.true;\r\nNone.should_not.be.ok;\r\n```\r\n\r\n# Python compatibility\r\n\r\n## Those are the python versions that support the assertions above [`CPython`](http://en.wikipedia.org/wiki/CPython)\r\n\r\n\r\n```\r\n\r\nPython ~= 2.6 (CPython)\r\nPython ~= 2.7 (CPython)\r\n\r\n```\r\n\r\n## Not supported:\r\n\r\n```\r\n\r\nJython\r\n\r\nPyPy\r\n\r\nIronPython\r\n\r\nUnladenSwallow\r\n\r\nStacklessPython\r\n\r\n...\r\n```\r\n\r\n## Why CPython-only ?\r\n\r\nSure has a slick algorithm that makes use of the\r\n[ctypes](http://docs.python.org/library/ctypes), and although it is\r\nalso available in other implementations such as\r\n[Jython](http://www.jython.org/) does have the `ctypes` module, only\r\nthe CPython provides\r\n[`ctypes.pythonapi`](http://docs.python.org/library/ctypes#loading-shared-libraries),\r\nrequired by sure.\r\n\r\n### Holy guacamole, how did you implement that feature ?\r\n\r\nDifferently of [ruby](http://www.ruby-lang.org) python doesn't have\r\n[open classes](http://blog.aizatto.com/2007/06/01/ruby-and-open-classes/),\r\nbut [Lincoln de Sousa](https://github.com/clarete/) came out with a\r\nsuper [sick code](https://github.com/gabrielfalcao/sure/blob/master/sure/magic.py) that uses the ctypes module to create a pointer to the\r\n`__dict__` of builtin types.\r\n\r\nYes, it is dangerous, non-pythonic and should not be used in production code.\r\n\r\nAlthough `sure` is here to be used __ONLY__ in test code, therefore it\r\nshould be running in __ONLY__ possible environments: your local\r\nmachine or your continuous-integration server.\r\n\r\n# About sure 1.0\r\n\r\nThe assertion library is 100% inspired be the awesomeness of\r\n[should.js](https://github.com/visionmedia/should.js) which is simple,\r\ndeclarative and fluent.\r\n\r\nSure strives to provide everything a python developer needs in an assertion:\r\n\r\n* Assertion messages are easy to understand\r\n\r\n* When comparing iterables the comparation is recursive and shows\r\n  exactly where is the error\r\n\r\n* Fluency: the builtin types are changed in order to provide awesome\r\n  simple assertions\r\n\r\n# Old API\r\n\r\nSure still provides to all the assertions from v0.10 up, you can [find the old documentation here](https://github.com/gabrielfalcao/sure/blob/master/OLD_API.md)\r\n\r\n## Authors\r\n\r\n[Gabriel Falcão](http://github.com/gabrielfalcao) and [Lincoln Clarete](http://github.com/clarete)\r\n\r\n\r\n# License (GPLv3)\r\n\r\n\r\n    Copyright (C) <2012>  Gabriel Falcão <gabriel@nacaolivre.org>\r\n    Copyright (C) <2012>  Lincoln Clarete <lincoln@comum.org>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n","name":"Sure","google":"UA-1277640-11"}